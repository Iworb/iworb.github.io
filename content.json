{"pages":[{"title":"About","permalink":"http://iworb.github.io/about/index.html","text":""},{"title":"Tags","permalink":"http://iworb.github.io/tags/index.html","text":""}],"posts":[{"title":"Full stack MEVN (MongoDb + Express + Vue + Node) проект на Node. Часть 2","permalink":"http://iworb.github.io/2018/02/09/mevn-02/","text":"Серверная часть. Продолжение банкетаLoggerЛоггирование это хорошо, особенно хорошо настроенное.Для этой задачи хорошо подходит библиотека winston, также не помешает еще одна маленькая библиотека mkdirp, задача которой создавать папки. Последняя нужна для того, если мы хотим сохранять логи в файл.1npm i -s winston winston-daily-rotate-file mkdirp Создадим файл “server/engine/logger.js”, который будет отвечать за логгирование на основание нашей конфигурации, но сначала занесем в конфиги начальные значения для настроек логгирования в файлы “server/config/base.js” и “server/config/config.template.js”:123456789101112logging: &#123; console: &#123; level: 'debug' &#125;, file: &#123; enabled: false, path: path.normalize(path.join(__dirname, '..', '..', 'logs')), level: 'info', json: false, exceptionFile: true &#125; &#125; Собственно, в файл “server/engine/logger.js” поместим следующий код:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const winston = require('winston')const path = require('path')const fs = require('fs')const mkdirp = require('mkdirp')const config = require('../config')const &#123;env&#125; = require('../lib')const transports = []/** * Console transporter */transports.push(new winston.transports.Console(&#123; level: config.logging.console.level, colorize: true, prettyPrint: true, handleExceptions: env.isProduction()&#125;))/** * File transporter */if (config.logging.file.enabled) &#123; // Create logs directory const logDir = config.logging.file.path if (!fs.existsSync(logDir)) &#123; mkdirp(logDir) &#125; transports.push(new (require('winston-daily-rotate-file'))(&#123; filename: path.join(logDir, 'server.log'), level: config.logging.file.level || 'info', timestamp: true, json: config.logging.file.json || false, handleExceptions: true &#125;)) if (config.logging.file.exceptionFile) &#123; transports.push(new winston.transports.File(&#123; filename: path.join(logDir, 'exceptions.log'), level: 'error', timestamp: true, json: config.logging.file.json || false, prettyPrint: true, handleExceptions: true, humanReadableUnhandledException: true &#125;)) &#125;&#125;const logger = new winston.Logger(&#123; level: 'debug', transports: transports, exitOnError: false&#125;)module.exports = logger И в файлах, где ранее выводилась информация в консоль с помощью console.log или console.info теперь можно подключать и использовать logger. Он куда лучше в том плане, что логи можно писать не только в консоль и файл, но и во внешние сервисы, которые опишем ниже.Для начала немного изменим “server/engine/espress.js”, где в функции initMiddleware во время режима отладки установим, чтобы morgan использовал наш логгер:1234567891011if (env.isDev()) &#123; const Stream = require('stream').Stream const mlStream = new Stream() mlStream.writable = true mlStream.write = data =\\&gt; &#123; return logger.debug(data) &#125; app.use(morgan('dev', &#123; stream: mlStream &#125;)) &#125; В файлах “server/engine/smoothExit.js”, “server/engine/sysinfo.js” и “server/index.js” также подключем логгер и задействуем его вместо console.Однако, логгер не затронет файлы конфигурации. Данные ошибки могут возникнуть только при старте сервера и нет необходимости их отправлять куда-либо еще.Для каждого из внешних сервисов логгирования нужно будет добавить библиотеку, расширить конфиги и добавить соответствующую функцию для winston. LogentriesМодуль:1npm i -s le_node Конфиги:1234logentries: &#123; enabled: false, token: null &#125; Функция:123456789101112/** * Logentries transporter* https://logentries.com/* */if (config.logging.logentries.enabled &amp;&amp; config.logging.logentries.token) &#123; console.log('Logentries log transport enabled!') require('le_node') transports.push(new winston.transports.Logentries(&#123; level: 'debug', token: config.logging.logentries.token &#125;)) &#125; PapertailМодуль:1npm i -s winston-papertrail Конфиги:1234567papertrail: &#123; enabled: false, host: null, port: null, level: 'debug', program: 'vem' &#125; Функция:12345678910/** * Papertrail transporter * https://papertrailapp.com/ */if (config.logging.papertrail.enabled) &#123; console.log('Papertrail log transport enabled!') // eslint-disable-next-line no-unused-expressions require('winston-papertrail').Papertrail transports.push(new winston.transports.Papertrail(config.logging.papertrail))&#125; LogglyМодуль:1npm i -s winston-loggly-bulk Конфиги:1234567loggly: &#123; enabled: false, token: null, subdomain: null, tags: [], json: true &#125; Функция (добавляется после объявления переменной logger):1234567891011121314/** * Loggly transporter * https://www.loggly.com/ */if (config.logging.loggly.enabled &amp;&amp; config.logging.loggly.token) &#123; console.log('Loggly log transport enabled!') require('winston-loggly-bulk') logger.add(winston.transports.Loggly, &#123; inputToken: config.logging.loggly.token, subdomain: config.logging.loggly.subdomain, tags: config.logging.loggly.tags, json: config.logging.loggly.json &#125;)&#125; LogseneМодуль:1npm i -s winston-logsene Конфиги:1234logsene: &#123; enabled: false, token: null &#125; Функция (добавляется после объявления переменной logger):123456789101112/** * Logsene transporter * https://sematext.com/logsene/ */if (config.logging.logsene.enabled &amp;&amp; config.logging.logsene.token) &#123; console.log('Logsene log transport enabled!') const logsene = require('winston-logsene') logger.add(logsene, &#123; type: 'vem-server', token: config.logging.logsene.token &#125;)&#125; Logz.ioМодуль:1npm i -s winston-logzio Конфиги:1234logzio: &#123; enabled: false, token: null &#125; Функция (добавляется после объявления переменной logger):1234567891011/** * Logz.io transporter * https://logz.io/ */if (config.logging.logzio.enabled &amp;&amp; config.logging.logzio.token) &#123; console.log('Logz.io log transport enabled!') const logzio = require('winston-logzio') logger.add(logzio, &#123; token: config.logging.logzio.token &#125;)&#125; GraylogМодуль:1npm i -s winston-graylog2 Конфиги:12345graylog: &#123; enabled: false, servers: \\[&#123;host: '192.168.1.100', port: 12201&#125;\\], facility: 'MEVN' &#125; Функция (добавляется после объявления переменной logger):12345678910111213141516/** * Graylog transporter * https://www.graylog.org/ */if (config.logging.graylog.enabled) &#123; console.log('Graylog log transport enabled! Servers: ' + JSON.stringify(config.logging.graylog.servers)) let graylog = require('winston-graylog2') logger.add(graylog, &#123; name: 'Graylog', level: 'debug', graylog: &#123; servers: config.logging.graylog.servers, facility: config.logging.graylog.facility &#125; &#125;)&#125; MongoDb"},{"title":"Full stack MEVN (MongoDb + Express + Vue + Node) проект на Node. Часть 1","permalink":"http://iworb.github.io/2018/02/09/mevn-01/","text":"Перед началомАктуальные версии Node и npm (или yarn), MongoDb должны быть предустановлены.Первым делом для проекта нужно создать папку1mkdir proj &amp;&amp; cd proj И инициализивать его1npm init Форматирование кодаДабы придерживаться общих правил форматирования рекомендуется использовать линтер для проверки форматирования кода. В данном примере будет использоваться eslint, который за основу использует стиль standard.12npm i --save-dev eslint.\\node_modules\\.bin\\eslint --init Выбираем Use a popular style guide, затем Standard и сохраняем в JSON.В итоге получим .eslintrc.json, в котором практически ничего не будет, расширим его:123456789101112131415&#123; \"env\": &#123; \"es6\": true, \"node\": true, \"mocha\": true &#125;, \"parserOptions\": &#123; \"ecmaVersion\": 8 &#125;, \"extends\": \"standard\", \"rules\": &#123; \"arrow-parens\": [\"error\", \"as-needed\"], \"linebreak-style\": [\"error\", \"unix\"] &#125; &#125; Переменная env показывает, в каких окружениях будет работать скрипт. ecmaVersion: 8 позволяет нам использовать конструкции вплоть до 8й версии ECMAScript.Отдельно про rules: arrow-parens изначально не прописан в Standard, позволяет не писать скобочки в стрелочных функциях, в которых всего 1 аргумент, т.е. можно так const f = a =&gt; {}, а можно и так const f = (a) =&gt; {}. linebreak-style также не прописан в Standard. Принудительно проверяет, чтобы все строки оканчивались переносом в Unix формате. Windows понимает оба типа переносов, а вот с Unix у меня были в некоторых случаях проблемы с CLRF переносами, поэтому лучше лишний раз это предусмотреть.Все остальные правила можно найти в .eslintrc.json от Standard.GitНу, куда же без контроля версий нашего проекта?Убедитесь, что у вас установлен git (или mercury) и инициализируйте новый локальный репозиторий1git init Прежде чем продолжать необходимо задать параметры, по которым файлы из проекта будут исключаться из контроля версий. К таким файлам должны относиться все временные файлы, файлы настроек окружения, файлы, создаваемые IDE, а также внешние зависимости (node_modules). Вот пример начальной конфигурации:12345678910111213141516171819202122232425262728293031################################################ # Dependencies ################################################ node_modules ################################################ # Node.js / NPM ################################################ lib-cov *.seed *.log *.out *.pid npm-debug.log ################################################ # Miscellaneous ################################################ *~ *# .DS_STORE .netbeans nbproject .idea .node_history dump.rdb .nuxt .vscode Со временем мы добавим правила для исключения файлов настроек, которые содержат секретные данные нашего проекта.Ну а пока можно и начать:1git commit -m &quot;Init&quot; ИнфраструктураПоскольку у нас будет full-stack приложение, то логично было бы отделить клиентскую часть и серверную, а также создать отдельную директорию для тестов:12345proj|-- client|-- node_modules|-- server|-- tests Серверная часть. Первые шагиConfigВ папке server создадим папку config и в ней 6 файлов:12345678server|-- config |-- base.js |-- config.template.js |-- dev.js |-- index.js |-- prod.js |-- test.js base.js - содержит основную конфигурацию приложения, которую не нужно будет в последствии изменять, чтобы создать новое приложений. config.template.js - шаблон пользовательского config.js на основании которого будет генерироваться файл config.js, в случае его отсутствия. Сгенерированный файл нужно добавить в .ginignore: server/config/sonfig.js index.js - файл, объединяющий всю конфигурацию. dev.js, prod.js, test.js - файлы конфигурации, которые будут подключены на основании текущей среды.Все файлы, кроме index.js, для начала инициируем так, чтобы они возвращали пустой объект:123module.exports = &#123; &#125; Для того, чтобы работать с вложенными словарями установим дополнительно lodash, а для более красивого вывода логов в консоль добавим chalk.1npm i -s chalk lodash Также, для создания пользовательского config.js было бы неплохо, чтобы secret генерировались для каждого нового приложения свои. В этом нам поможет uuid-token-generator:1npm i -s uuid-token-generator Создадим в папке server папку lib, которая будет отвечать за полезные функции.Добавим в неё несколько файлов:dev.js отвечает за получение информации об окружении:12345678910111213module.exports = &#123; isDev () &#123; return !process.env.NODE_ENV || process.env.NODE_ENV === 'development' &#125;, isProduction () &#123; return process.env.NODE_ENV === 'production' &#125;, isTest () &#123; return process.env.NODE_ENV === 'test' &#125; &#125; tokgen.js отвечает за генерацию токенов:123456let TokenGenerator = require('uuid-token-generator') let tokgen = new TokenGenerator(256, TokenGenerator.BASE62) module.exports = function () &#123; return tokgen.generate() &#125; index.js объединяет всё:1234567const env = require('./env)const tokgen = require('./tokgen') module.exports = &#123; env, tokgen &#125; В итоге у нас получилась такая структура:12345server|-- lib |-- dev.js |-- index.js |-- tokgen.js Теперь мы готовы начать работать с конфигурацией. Для начала добавим в base.js информацию о сессиях:1234567891011121314151617module.exports = &#123; session: &#123; resave: true, saveUninitialized: false, cookie: &#123; // reset session after 1 week maxAge: 7 \\* 24 \\* (60 \\* 60 \\* 1000), // we will use cookies just for HTTP, not js // JS will send this cookies only from current domain httpOnly: true, // should be 'true' if you're using https secure: false &#125;, // MongoDb collection name to store sessions // It let you persist sessions when you restart server collection: 'sessions' &#125; &#125; А в config.template.js о ключе сессии:12345module.exports = &#123; session: &#123; secret: '&#123;&#123;sessionSecret&#125;&#125;' &#125; &#125; Теперь же объединим всю конфигурации и создадим файл config.js на основании шаблона. Для этого в index.js мы должны сделать следующее:123456789101112131415161718192021222324252627282930313233343536373839404142const path = require('path') const fs = require('fs') const _ = require('lodash') const chalk = require('chalk') const &#123;tokgen, env&#125; = require('../lib') const base = require('./base') // [1]let user = &#123;&#125; try &#123; // [2] if (!fs.existsSync(path.join(__dirname, 'config.js'))) &#123; console.warn(chalk.yellow.bold('`config.js` for server settings was not found! Generating new `config.js` file')) const template = fs.readFileSync(path.join(__dirname, 'config.template.js')) _.templateSettings.interpolate = /&#123;&#123;([\\s\\S]+?)&#125;&#125;/g const compiled = _.template(template) const replacements = &#123; sessionSecret: tokgen() &#125; fs.writeFileSync(path.join(__dirname, 'config.js'), compiled(replacements)) console.warn(chalk.green.bold('New `config.js` for server settings file was generated. You could update your settings here: \"server/config/config.js\"')) &#125; user = require('./config') &#125; catch (error) &#123; console.warn(chalk.red.bold('\\r\\n==============================================')) console.warn(chalk.red.bold(' Unable to load external `config.js` file!')) console.warn(chalk.red.bold(' ', error)) console.warn(chalk.red.bold('==============================================\\r\\n')) process.exit(1) &#125; let extra = &#123;&#125; // [3] if (env.isDev()) &#123; extra = require('./dev') &#125; else if (env.isTest()) &#123; extra = require('./test') &#125; else if (env.isProduction()) &#123; extra = require('./prod') &#125; module.exports = _.defaultsDeep(extra, user, base) Сперва мы подключили основной конфиг [1] и объявили переменную для расширенного. Она должна находиться в данном контексте, чтобы в итоге объединить все файлы в один.Далее [2] мы проверяем, существует ли в данной папке файл config.js и, если его нет, то генерируем новый. Для этого мы считываем шаблон, в настройках интерполяции указываем, что нужно читать все переменные, которые заключены в двойные фигурные скобки. Затем, объявляем на что мы будем каждую из переменных заменять и генерируем новый файл, который ниже подключается через переменную user.Затем [3] нужно подключить конфигурационный файл, который зависит от среды разработки. Так, у нас могут быть разные базы для разработки, продакшена и тестирования, разные ключи и т.п.По итогу мы возвращаем массив, собрав его таким образом, что приоритет отдается конфигурации, которая зависит от среды разработки, затем подключается config.js, а все остальное берется из base.js.Чтобы проверить, что всё работает, можно запустить следующую команду из корня проекта:1node server\\config\\index.js Результатом работы будет созданный файл “server/config/config.js” с secret для сессий.В дальнейшем конфиг будет расширяться и дополняться. ExpressДля начала немного расширим наши настройки, добавив в base.js следующее:12345678910const path = require('path')module.exports = &#123; ip: process.env.NODE_IP || '0.0.0.0', port: process.env.NODE_PORT || 3000, ... path: &#123; server: path.normalize(path.join(__dirname, '..')), root: path.normalize(path.join(__dirname, '..', '..')) &#125;&#125; Теперь у нас есть информация о том, на каком адресе и порте будет запущен сервер и о директориях, где находится наша серверная часть и проект в целом.Создадим в директории server директорию engine, которая будет отвечать за все файлы, связанные с инициализацией сервера. В ней создадим express.js.Установим необходимый набор модулей: express - собственно, фреймворк express-session - сессии compression - сжатие отправляемых данных cookie-parser и body-parser - парсеры для cookie и тела запроса соответственно helmet - дополнительная защита от части уязвимостей morgan - логгер запросов1npm i -s express express-session compression cookie-parser body-parser helmet morgan Собственно, наш express.js будет для начала выглядеть так:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const config = require('../config') const &#123;env&#125; = require('../lib') const express = require('express') const session = require('express-session') const compress = require('compression') const cookieParser = require('cookie-parser') const bodyParser = require('body-parser') const helmet = require('helmet') const morgan = require('morgan') /** * Initialize middlewares* @param &#123;any&#125; app */function initMiddleware (app) &#123; app.use(compress(&#123; filter: (req, res) =&gt; &#123; return /json|text|javascript|css/.test(res.getHeader('Content-Type')) &#125;, level: 3, threshold: 512 &#125;)) app.set('port', config.port) app.use(bodyParser.urlencoded(&#123; extended: true &#125;)) app.use(bodyParser.json()) app.use(cookieParser()) app.set('etag', true) if (env.isDev()) &#123; app.use(morgan('dev')) &#125; &#125; /** * Initialize session* @param &#123;any&#125; app */function initSession (app) &#123; app.use(session(config.session)) &#125; /** * Initiliaze Helmet security module* @param &#123;any&#125; app */function initHelmetHeaders (app) &#123; app.use(helmet.xssFilter()) app.use(helmet.noSniff()) app.use(helmet.frameguard()) app.use(helmet.ieNoOpen()) app.use(helmet.hidePoweredBy()) &#125; module.exports = () =&gt; &#123; const app = express() initMiddleware(app) initHelmetHeaders(app) initSession(app) return app &#125; Я выделил на данный момент 3 функции: initMiddleware - инициализирует основные middleware для сжатия, парсинга и мониторинга (в режиме разработчика). initHelmetHeaders - инициализирует защиту заголовков. initSession - инициализирует сессии.Добавим еще одну библиотеку для форматирования времени:1npm i -s moment Для безопасной остановки сервера добавим собственную библиотеку “server/lib/smoothExit.js”:123456789const chalk = require('chalk') const moment = require('moment') const smoothExit = () =\\&gt; &#123; console.log(chalk.bold('---------------------\\[ Server stopped at %s Uptime: %s \\]---------------------------'), moment().format('YYYY-MM-DD HH:mm:ss.SSS'), moment.duration(process.uptime() * 1000).humanize()) return process.exit(0) &#125; process.on('SIGINT', smoothExit).on('SIGTERM', smoothExit) Также добавим небольшую библиотеку для вывода информации о системе:1npm i -s clui pretty-bytes 1234567891011121314const os = require('os') const gauge = require('clui').Gauge const pretty = require('pretty-bytes') module.exports = () =&gt; &#123; const total = os.totalmem() const free = os.freemem() const used = total - free const human = pretty(free) console.info(`CPU:\\t\\t\\tArch: $&#123;os.arch()&#125;, Cores: $&#123;os.cpus().length&#125;`) console.info(`Memory:\\t\\t\\t$&#123;gauge(used, total, 20, total * 0.8, human + ' free')&#125;`) console.info(`OS:\\t\\t\\t\\t$&#123;os.platform()&#125; ($&#123;os.type()&#125;)`) &#125; Ну и наконец, наш “server/index.js”, который будет являться точкой входа для всего приложения:1234567891011121314151617181920const config = require('./config') const chalk = require('chalk') const app = require('./engine/express')() require('./lib/smoothExit') app.listen(config.port, config.ip, () =&gt; &#123; console.info('') console.info('Application started!') console.info('----------------------------------------------') console.info(`Environment:\\t$&#123;chalk.underline.bold(process.env.NODE_ENV)&#125;`) console.info(`IP:\\t\\t\\t\\t$&#123;config.ip&#125;`) console.info(`Port:\\t\\t\\t$&#123;config.port&#125;`) console.info('') require('./lib/sysinfo') &#125;) exports = module.exports = app Теперь можно запустить нашу серверную часть, но для начала установим полезную библиотеку, которая перезапускает сервер в случае изменения файлов:1npm i -g nodemon А в файл package.json в раздел scripts добавим новый скрипт:1&quot;dev&quot;: &quot;nodemon --inspect&quot; Теперь можем запустить его через npm:1npm run dev Сервер работает, но пока он ровным счетом не делает ничего, поэтому в следующей части мы создадим более удобный логгер, подключим базу данных, создадим модели и маршруты для REST API."}]}