{"pages":[{"title":"Tags","permalink":"http://iworb.github.io/tags/index.html","text":""},{"title":"About","permalink":"http://iworb.github.io/about/index.html","text":""}],"posts":[{"title":"Full Stack (Node + Express + MongoDb + Vue + Nuxt) application. Part 7: Visual part","permalink":"http://iworb.github.io/2018/02/15/07-nemvn/","text":""},{"title":"Full Stack (Node + Express + MongoDb + Vue + Nuxt) application. Part 6: Authentication","permalink":"http://iworb.github.io/2018/02/15/06-nemvn/","text":"I highly recommend to use Postman to test your REST api, especially in this part.Let’s get started with authentication with installing passport.js and some requirements:1yarn add passport passport-local Make an auth directory in your engine. Passport has different strategies to authenticate and it could be split in separate files.It should be init after our session, but before router:123456789101112module.exports = db =&gt; &#123; const app = express() initMiddleware(app) initHelmetHeaders(app) initSession(app, db) require('./auth')(app) // Here require('@routes')(app, initNuxt) return app&#125; Now we can should handle this in server/engine/auth/index.js:1234567891011121314151617181920212223242526272829303132const logger = require('@engine/logger')const User = require('@models/user')const passport = require('passport')const chalk = require('chalk')module.exports = app =&gt; &#123; app.use(passport.initialize()) app.use(passport.session()) passport.serializeUser((user, done) =&gt; &#123; done(null, user.id) &#125;) passport.deserializeUser(function (id, done) &#123; User.findById(id, '-local.password') .then(user =&gt; &#123; // Check that the user is not disabled or deleted if (user.status !== 1) return done(null, false) return done(null, user) &#125;) .catch(done) &#125;) logger.info(chalk.bold('Passport strategies initialization...')) // [1] const strategies = ['local'] strategies.forEach(strategy =&gt; &#123; logger.info(`Loading $&#123;strategy&#125; passport strategy`) require(`./strategies/$&#123;strategy&#125;`) &#125;)&#125; Skip default passport initialization, let’s talk about strategies. Currently I’ve made strategies directory and create local strategy (description below) and load it in [1]. Yes, I could read filesystem, or create another index file to export all strategies I have, but there’s no reason to do that. Strategies changes quite seldom and we could handle this by adding it names in the strategies array of file names.Local login strategy is simple:123456789101112131415161718192021222324252627const c = require('@engine/constants')const User = require('@models/user')const &#123;FieldsError&#125; = require('@engine/errors')const passport = require('passport')const LocalStrategy = require('passport-local').Strategypassport.use('local', new LocalStrategy(&#123; usernameField: 'username', passwordField: 'password', passReqToCallback: true&#125;, async (req, username, password, done) =&gt; &#123; try &#123; const user = await User.findOne(&#123; $or: [ &#123;name: username&#125;, &#123;'local.email': username&#125; ] &#125;) if (!user) return done(new FieldsError(&#123;username: c.E.NOT_FOUND&#125;)) if (user.status !== 1) return done(new FieldsError(&#123;username: c.E.DISABLED&#125;)) if (!(await user.verifyPassword(password))) return done(new FieldsError(&#123;password: c.E.INVALID&#125;)) return done(null, user) &#125; catch (err) &#123; return done(err) &#125;&#125;)) Just check user existance, his status and password.You may see new FieldsError class. It’s been made for throwing Validation-like errors.All custom errors will take their place at server/engine/errors directory. Here’s fieldsError.js:12345678module.exports = class FormError extends Error &#123; constructor (fields, message, status) &#123; super(message) this.status = status || 400 this.fields = fields Error.captureStackTrace(this, this.constructor) &#125;&#125; And index.js placed nearby:12345const FieldsError = require('./fieldsError')module.exports = &#123; FieldsError&#125; We described strategies, so let’s describe routes for auth in server/routes/auth.js:1234567891011121314151617181920212223const c = require('@engine/constants')const response = require('@engine/response')const passport = require('passport')const router = require('express').Router()router.post('/login', (req, res, next) =&gt; &#123; passport.authenticate('local', (err, user, info) =&gt; &#123; if (err) return next(err) if (!user) return response.json(res, null, response.BAD_REQUEST, c.E.NOT_FOUND) req.login(user, err =&gt; &#123; if (err) return next(err) return res.json(true) &#125;) &#125;)(req, res, next)&#125;)router.post('/logout', (req, res) =&gt; &#123; req.logout() res.redirect('/')&#125;)module.exports = router Finally, add it to routes index and don’t forget about our custom errors:1234567891011121314...const EngineErrors = require('@engine/errors')...module.exports = (app, ...middlewares) =&gt; &#123; app.use(require('./auth')) router.use('/users', require('./user')) ... &#125; else if (err instanceof EngineErrors.FieldsError) &#123; return response.json(res, null, response.BAD_REQUEST, null, &#123;fields: err.fields&#125;) &#125; else &#123; return response.json(res, null, response.SERVER_ERROR, err.message) &#125; ... Also, we can invalidate user update if new password and confirmation doesn’t match (user model):123456789101112131415161718192021222324252627282930const &#123;FieldsError&#125; = require('@engine/errors')...userSchema.statics.updateUser = function (req, res, next) &#123; let values = _.pick(req.body, _.keys(userSchema.paths)) if (values._id) delete values._id values = _.pickBy(flatten(values), _.identity) if ( ((req.body.passNew &amp;&amp; req.body.passNew.length) || (req.body.passNewConfirm &amp;&amp; req.body.passNewConfirm.length)) &amp;&amp; req.body.passNew !== req.body.passNewConfirm) &#123; return next(new FieldsError(&#123;passNew: c.E.NOT_MATCH, passNewConfirm: c.E.NOT_MATCH&#125;)) &#125; return this.findById(req.params.id) .then(user =&gt; &#123; if (req.body.passNew) &#123; if (_.isUndefined(values['local.password'])) &#123; throw user.invalidate('local.password', c.E.REQUIRED) &#125; if (!user.verifyPasswordSync(values['local.password'])) &#123; throw user.invalidate('local.password', c.E.NOT_VALID) &#125; values['local.password'] = req.body.passNew &#125; return user.update(values) &#125;) .then(() =&gt; &#123; return res.json(true) &#125;) .catch(next)&#125; Finally, let’s make some middleware helpers (server/engine/auth/helpers.js):1234module.exports.isAuthenticated = (req, res, next) =&gt; &#123; if (req.isAuthenticated()) return next() else res.sendStatus(401)&#125; Currently anyone can get users list and information about any user, even delete or modify some fields. Let’s improve this: List of all users - limit for all list requests, retrieve names only; User details - no changes; User create - no changes; User edit - only owner (currently) should have permissions to edit; User delete - noone (currently) should have permissions to delete user.Let’s make some new routes for this purpose: post /signup - same as post to /users, create new user; get /users/me - same as get /users/:id, but id is current user id; patch /users/me - same as patch /users/:id, but id is current user id;First of all, let’s limit of user list retrieve (server/routes/user.js):12345678910111213141516171819router.get('/', (req, res, next) =&gt; &#123; const limit = req.body.limit || req.query.limit || 50 let page = req.body.page || req.query.page || 1 let total if (page &lt; 1) page = 1 page-- User.count() .then(c =&gt; &#123; total = c return User.find(&#123;&#125;, &#123;name: 1&#125;).limit(limit).skip(limit * page) &#125;) .then(users =&gt; &#123; return res.json(&#123; total: total, items: users &#125;) &#125;) .catch(next)&#125;) To achieve /signup behaviour we have to move our user creation logic from router to model:123456789userSchema.statics.createUser = function (req, res, next) &#123; let values = _.pick(req.body, _.keys(userSchema.paths)) if (values._id) delete values._id values = _.pickBy(flatten(values), _.identity) const newUser = new this(values) return newUser.save().then(user =&gt; &#123; return response.json(res, _.omit(user.toObject(), 'local.password')) &#125;).catch(next)&#125; server/routes/user.js changes:1router.post('/', User.createUser.bind(User)) server/routes/auth.js:1router.post('/signup', User.createUser.bind(User)) To get /users/me we should define handler before /users/:id, otherwise it will try to fetch user with id=&#39;me&#39;:12345const &#123;isAuthenticated&#125; = require('@engine/auth/helpers')...router.get('/me', isAuthenticated, (req, res, next) =&gt; &#123; return res.json(req.user.toObject())&#125;) Patch /users/me looks similar, deleting user now will throw error:123456789101112router.patch('/me', isAuthenticated, User.updateUser.bind(User))router.patch('/:id', isAuthenticated, User.updateUser.bind(User))router.delete('/:id', (req, res, next) =&gt; &#123; return response(res, null, response.REQUEST_FAILED) // User.findByIdAndRemove(req.params.id) // .then(() =&gt; &#123; // return res.json(true) // &#125;) // .catch(next)&#125;) And the last thing is modifying updateUser function because we should handle new route:12345678910111213141516171819202122232425262728userSchema.statics.updateUser = async function (req, res, next) &#123; let values = _.pick(req.body, _.keys(userSchema.paths)) if (values._id) delete values._id values = _.pickBy(flatten(values), _.identity) if ( ((req.body.passNew &amp;&amp; req.body.passNew.length) || (req.body.passNewConfirm &amp;&amp; req.body.passNewConfirm.length)) &amp;&amp; req.body.passNew !== req.body.passNewConfirm) &#123; return next(new FieldsError(&#123;passNew: c.E.NOT_MATCH, passNewConfirm: c.E.NOT_MATCH&#125;)) &#125; try &#123; const user = req.params.id ? await this.findById(req.params.id) : req.user if (user._id !== req.user._id) return response.json(res, null, response.FORBIDDEN, c.E.DENIED) if (req.body.passNew) &#123; if (_.isUndefined(values['local.password'])) &#123; return next(user.invalidate('local.password', c.E.REQUIRED)) &#125; if (!user.verifyPasswordSync(values['local.password'])) &#123; return next(user.invalidate('local.password', c.E.NOT_VALID)) &#125; values['local.password'] = req.body.passNew &#125; await user.update(values) return res.json(true) &#125; catch (err) &#123; return next(err) &#125;&#125; Now user can edit only himself.NB: there’s some more constants added into server/engine/constants.js:1234'DENIED': 'E_DENIED','DISABLED': 'E_DISABLED','INVALID': 'E_INVALID','NOT_FOUND': 'E_NOT_FOUND', This part wraps up 05-auth git branch."},{"title":"Full Stack (Node + Express + MongoDb + Vue + Nuxt) application. Part 5: Models and Routes. User","permalink":"http://iworb.github.io/2018/02/15/05-nemvn/","text":"UserModelWhen you’re talking about user you may find plenty things of properties he could have.Let’s check out main ones: name - aka username; email - unique user e-mail used for local login; password - user password’s hash for local login; status - user could be “active”, “not-verified”, “banned”, etc. Best practice is using predefined status codes.Now we’re ready to create our first model.All models will land in server/models directory, don’t forget to create module alias for it:12&quot;@models&quot;: &quot;./server/models&quot;,&quot;@routes&quot;: &quot;./server/routes&quot; To work with model from outside we have to define routes which can handle request and modify documents. That’s why we created module alias for server/routes directory. We’ll be back soon to describe it behaviour.Let’s look at user.js model:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138const c = require('@engine/constants')const mongoose = require('mongoose')const crypto = require('crypto')const bcrypt = require('bcrypt')const flatten = require('flat')const _ = require('lodash')const validateLocalStrategyProperty = function (property) &#123; return property &amp;&amp; property.length&#125;const validateLocalStrategyPassword = function (password) &#123; return password &amp;&amp; password.length &gt;= 6&#125;const userSchema = mongoose.Schema(&#123; name: &#123; type: String, trim: true, unique: true, index: true, default: '', validate: [validateLocalStrategyProperty, c.E.REQUIRED] &#125;, local: &#123; email: &#123; type: String, trim: true, index: true, lowerCase: true, default: '', unique: true, match: [/.+@.+\\..+/, c.E.NOT_VALID], validate: [validateLocalStrategyProperty, c.E.REQUIRED] &#125;, password: &#123; type: String, default: '', validate: [validateLocalStrategyPassword, [c.E.MIN_LENGTH, 6]] &#125; &#125;, profile: &#123; name: &#123;type: String&#125;, gender: &#123;type: String&#125;, picture: &#123;type: String&#125; &#125;, status: &#123; type: Number, default: 1 &#125;&#125;, &#123; timestamps: true, toObject: &#123; virtuals: true &#125;, toJSON: &#123; virtuals: true &#125;&#125;)async function protectPassword (next) &#123; if (typeof this.getUpdate === 'function') &#123; if (this.getUpdate()['local.password']) &#123; this.getUpdate()['local.password'] = await bcrypt.hash(this.getUpdate()['local.password'], 12) &#125; &#125; else &#123; if (this.isModified('local.password')) &#123; this.local.password = await bcrypt.hash(this.local.password, 12) &#125; &#125; return next()&#125;userSchema.pre('save', protectPassword)userSchema.pre('update', protectPassword)userSchema.methods.verifyPassword = function (password) &#123; return bcrypt.compare(password, this.local.password)&#125;userSchema.methods.verifyPasswordSync = function (password) &#123; return bcrypt.compareSync(password, this.local.password)&#125;userSchema.virtual('avatar').get(function () &#123; if (this.profile &amp;&amp; this.profile.picture) &#123; return this.profile.picture &#125; const getRandomUserAvatarId = str =&gt; &#123; let c = 0 for (let i = 0; i &lt; str.length; i++) &#123; c += str.charCodeAt(i) &#125; return c % 100 &#125; const email = this.local.email if (!email) &#123; const g = this.profile &amp;&amp; this.profile.gender === 'female' ? 'women' : 'men' return `https://randomuser.me/api/portraits/thumb/$&#123;g&#125;/$&#123;getRandomUserAvatarId(this.local.name)&#125;.jpg` &#125; else &#123; const hash = crypto.createHash('md5').update(email).digest('hex') return `https://gravatar.com/avatar/$&#123;hash&#125;?s=64&amp;d=wavatar` &#125;&#125;)userSchema.statics.updateUser = function (req, res, next) &#123; let values = _.pick(req.body, _.keys(userSchema.paths)) if (values._id) delete values._id values = _.pickBy(flatten(values), _.identity) return this.findById(req.params.id) .then(user =&gt; &#123; if ( ((req.body.passNew &amp;&amp; req.body.passNew.length) || (req.body.passNewConfirm &amp;&amp; req.body.passNewConfirm.length)) &amp;&amp; req.body.passNew !== req.body.passNewConfirm) &#123; user.invalidate('passNew', c.E.NOT_MATCH) throw user.invalidate('passNewConfirm', c.E.NOT_MATCH) &#125; if (req.body.passNew) &#123; if (_.isUndefined(values['local.password'])) &#123; throw user.invalidate('local.password', c.E.REQUIRED) &#125; if (!user.verifyPasswordSync(values['local.password'])) &#123; throw user.invalidate('local.password', c.E.NOT_VALID) &#125; values['local.password'] = req.body.passNew &#125; return user.update(values) &#125;) .then(() =&gt; &#123; return res.json(true) &#125;) .catch(next)&#125;module.exports = mongoose.model('User', userSchema) Also, we need bcrypt package for password hashing and flat for flattern objects, so let’s add it:1yarn add bcrypt flat There’s some nifty functions for make sure password doesn’t store in database, hash only. And little bit functions for profile and avatars.Timestamps are turned on and virtuals are included in toJSON and toObject conversion.We’re return error codes instead of messages.Pros: No need to know user locale; No need to repeat error message in different places.Cons: Error message should be passed as array because of an additional information like numbers (min, max), templates, etc.Let’s create constants.js in the server/engine directory:1234567891011module.exports = &#123; 'E': &#123; 'REQUIRED': 'E_REQUIRED', 'UNIQUE': 'E_UNIQUE', 'NOT_VALID': 'E_NOT_VALID', 'NOT_MATCH': 'E_NOT_MATCH', 'MIN_LENGTH': 'E_MIN_LENGTH', 'MAX_LENGTH': 'E_MAX_LENGTH', 'NOT_IN_RANGE': 'E_NOT_IN_RANGE' &#125;&#125; Transforming password into hash should be called each time user saved or updated.Also, we have to be sure that only filled keys should be picked on user update. To set nested objects like local.password we have to make object flat. If we don’t - local key will be completely replaced with a new one.The last thing is to check password if we want to set new one. RouteBefore handling routes let’s make one more thing: custom response behaviour.Why do we need that? Send errors in response in easy way; Custom error messages, extra error data, predefined status codes, etc.server/engine/response.js:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475const _ = require('lodash')module.exports = &#123; BAD_REQUEST: &#123; status: 400, type: 'BAD_REQUEST' &#125;, UNAUTHORIZED: &#123; status: 401, type: 'UNAUTHORIZED' &#125;, REQUEST_FAILED: &#123; status: 402, type: 'REQUEST_FAILED' &#125;, FORBIDDEN: &#123; status: 403, type: 'FORBIDDEN' &#125;, NOT_FOUND: &#123; status: 404, type: 'NOT_FOUND' &#125;, TOO_MANY_REQUEST: &#123; status: 429, type: 'TOO_MANY_REQUEST' &#125;, SERVER_ERROR: &#123; status: 500, type: 'SERVER_ERROR' &#125;, NOT_IMPLEMENTED: &#123; status: 501, type: 'NOT_IMPLEMENTED' &#125;, /** * Generate a JSON REST API response * * If data present and no error, we will send status 200 with JSON data * If no data but has error, we will send HTTP error code and message * * @param &#123;Object&#125; res ExpressJS res object * @param &#123;Object&#125; data Response data * @param &#123;Object&#125; err Error object * @param &#123;String&#125; errMessage Custom error message * @param &#123;Object&#125; extraParams Extra error params * @return &#123;*&#125; If res assigned, return with res, otherwise return the response JSON object */ json (res, data, err, errMessage, extraParams) &#123; const response = &#123;&#125; if (err) &#123; response.error = err response.status = err.status || 500 if (errMessage) &#123; response.error.message = errMessage.message || errMessage &#125; if (extraParams &amp;&amp; _.isObject(extraParams)) response.error = _.assign(response.error, extraParams) response.data = data if (res) res.status(response.status) &#125; else &#123; response.status = 200 response.data = data &#125; return res ? res.json(response) : response &#125;&#125; Now we ready to make our routing system. Let’s make index.js and user.js files in server/routes directory. index file will gather all routes. user and other ones have to return express-router instance for smooth implementation.Let’s take a look in user.js:1234567891011121314151617181920212223242526272829303132333435363738394041424344const response = require('@engine/response')const User = require('@models/user')const _ = require('lodash')const flatten = require('flat')const router = require('express').Router()router.get('/', (req, res, next) =&gt; &#123; User.find(&#123;&#125;, &#123;'local.password': 0&#125;) .then(users =&gt; &#123; return res.json(users) &#125;) .catch(next)&#125;)router.get('/:id', (req, res, next) =&gt; &#123; User.findById(req.params.id, &#123;'local.password': 0&#125;) .then(user =&gt; &#123; return res.json(user) &#125;) .catch(next)&#125;)router.post('/', (req, res, next) =&gt; &#123; let values = _.pick(req.body, _.keys(User.schema.paths)) if (values._id) delete values._id values = _.pickBy(flatten(values), _.identity) const newUser = new User(values) return newUser.save().then(user =&gt; &#123; return response.json(res, _.omit(user.toObject(), 'local.password')) &#125;).catch(next)&#125;)router.patch('/:id', User.updateUser.bind(User))router.delete('/:id', (req, res, next) =&gt; &#123; User.findByIdAndRemove(req.params.id) .then(() =&gt; &#123; return res.json(true) &#125;) .catch(next)&#125;)module.exports = router Just a REST api, nothing else.Now index.js:12345678910111213141516171819202122232425262728293031323334353637383940414243const c = require('@engine/constants')const logger = require('@engine/logger')const response = require('@engine/response')const mongoose = require('mongoose')const _ = require('lodash')const router = require('express').Router()module.exports = (app, ...middlewares) =&gt; &#123; router.use('/users', require('./user')) app.use('/api', router) // [1] middlewares.forEach(middleware =&gt; middleware(app)) app.use((err, req, res, next) =&gt; &#123; if (!err) return next() logger.error(err.stack) // [2] if (err instanceof mongoose.Error.ValidationError) &#123; const fields = &#123;&#125; _.each(err.errors, e =&gt; &#123; fields[e.path] = _.isArray(e.properties) ? e.properties : e.message &#125;) return response.json(res, null, response.BAD_REQUEST, null, &#123;fields&#125;) &#125; else if (err.name &amp;&amp; err.name === 'BulkWriteError') &#123; switch (err.code) &#123; case 11000: let field = err.message.split('.$')[1] field = field.split(' dup key')[0] field = field.substring(0, field.lastIndexOf('_')) return response.json(res, null, response.BAD_REQUEST, null, &#123;fields: &#123;[field]: c.E.UNIQUE&#125;&#125;) &#125; &#125; else &#123; return response.json(res, null, response.SERVER_ERROR, err.message) &#125; &#125;) app.use((req, res) =&gt; &#123; return response.json(res, null, response.NOT_FOUND) &#125;)&#125; There’s some unclear code. The function accepts app argument and ...middlewares. The last one contains middlewares which should be init after routes defined, but before error hadling. In our case it’s Nuxt. We can’t define it before routes, because we won’t reach them (Nuxt middleware won’t call next function) and we can’t define it after error handling, because 404 error will be returned before Nuxt.In server/engine/express.js we should call routes initialization:1234567891011module.exports = db =&gt; &#123; const app = express() initMiddleware(app) initHelmetHeaders(app) initSession(app, db) require('@routes')(app, initNuxt) return app&#125; We’re also have custom check for ValidationError to retrieve fields which was invalid with error messages (or arrays with message and arguments) and BulkWriteError for unique validation (it’s a bit different than Validation one).This part wraps up 05-user git branch."},{"title":"Full Stack (Node + Express + MongoDb + Vue + Nuxt) application. Part 4: MongoDb","permalink":"http://iworb.github.io/2018/02/13/04-nemvn/","text":"ConnectionWe’re going to use mongoose to communicate with our MongoDb instance. Make sure MongoDb running and configured.For storing sessions in the database we also need connect-mongo package.1yarn add mongoose connect-mongo Configs for mongo connection looks like this:12345678910db: &#123; uri: 'mongodb://localhost/nemvn?authSource=admin', options: &#123; user: 'admin', pass: 'admin', socketTimeoutMS: 0, keepAlive: true, reconnectTries: 30 &#125;&#125; Make sure you’re set correct user and pass for your mongo instance. If there’s no auth - just remove this options from list. InitializationMongoDb initialization will be described in server/engine/mongo.js:123456789101112131415161718192021222324252627282930313233343536373839404142const config = require('@config')const logger = require('@engine/logger')const &#123;env&#125; = require('@helpers')const chalk = require('chalk')const mongoose = require('mongoose')module.exports = () =&gt; &#123; mongoose.Promise = global.Promise if (mongoose.connection.readyState !== 1) &#123; logger.info(`Connecting to Mongo $&#123;config.db.uri&#125; ...`) mongoose.connection.on('error', err =&gt; &#123; if (err.message.code === 'ETIMEDOUT') &#123; logger.warn('Mongo connection timeout!', err) setTimeout(() =&gt; &#123; mongoose.connect(config.db.uri, config.db.options) &#125;, 1000) return &#125; logger.error('Could not connect to MongoDB!') return logger.error(err) &#125;) mongoose.connection.once('open', () =&gt; &#123; logger.info(chalk.yellow.bold('Mongo DB connected.')) logger.info() &#125;) mongoose.connect(config.db.uri, config.db.options) .then(() =&gt; &#123; mongoose.set('debug', env.isDev()) &#125;) .catch(err =&gt; &#123; logger.error('Could not connect to MongoDB!') return logger.error(err) &#125;) &#125; else &#123; logger.info('Mongo already connected.') &#125; return mongoose.connection&#125; Connection process is simple. There’s some extra handlers for logging.We should init MongoDb before express:12const db = require('@engine/mongo')()const app = require('@engine/express')(db) SessionNow we can use this MongoDb instance as session storage.As you can see above, we passed db constant into express init function, let’s handle this:1234567891011121314151617181920212223242526const MongoStore = require('connect-mongo')(session).../** * Initialize session * @param &#123;any&#125; app * @param &#123;db&#125; db */function initSession (app, db) &#123; const configSession = config.session configSession.store = new MongoStore(&#123; mongooseConnection: db, autoReconnect: true &#125;) app.use(session(configSession))&#125;...module.exports = db =&gt; &#123; const app = express() initMiddleware(app) initHelmetHeaders(app) initSession(app, db) initNuxt(app) return app&#125; Now all sessions will be saved in the database.NB: we’re saving just initialized sessions of authorized users. There’s no users atm, so you could set saveUninitialized to true in your config to look how it works. Close connectionThe final thing is about connection closing when server have to stop. Let’s modify helper safeStop.js:1234567891011121314151617181920212223const logger = require('@engine/logger')const env = require('./env')const chalk = require('chalk')const moment = require('moment')const mongoose = require('mongoose')const smoothExit = async () =&gt; &#123; const exit = () =&gt; &#123; logger.info() logger.info(chalk.bold('------[ Server stopped at %s Uptime: %s ]------'), moment().format('YYYY-MM-DD HH:mm:ss.SSS'), moment.duration(process.uptime() * 1000).humanize()) return process.exit(0) &#125; if (mongoose.connection.readyState === 0) &#123; return exit() &#125; else &#123; if (env.isTest()) await mongoose.connection.dropDatabase() await mongoose.connection.close() return exit() &#125;&#125;process.on('SIGINT', smoothExit).on('SIGTERM', smoothExit) This part wraps up 04-mongo git branch."},{"title":"Full Stack (Node + Express + MongoDb + Vue + Nuxt) application. Part 3: Logging, initialization splitting and more helpers","permalink":"http://iworb.github.io/2018/02/13/03-nemvn/","text":"LoggingConsole logging is good, but it doesn’t cover all needs. Server could turn off instantly and you won’t see any messages, or there’s plenty errors and you have no time to read a single one, etc.Let’s take a look for other logging variations.There’s already good module to achieve different behaviours:1yarn add winston Files, belong using for init our application and other nifty functions which require config will land into server/engine directory. Make sure to include it into your module aliases list:1&quot;@engine&quot;: &quot;./server/engine&quot; Lets make a new file logger.js with console output:12345678910111213141516171819202122232425262728const winston = require('winston')const config = require('@config')const &#123;env&#125; = require('@helpers')const transports = []/** * Console transporter */transports.push(new winston.transports.Console(&#123; level: config.logging.console.level, colorize: true, prettyPrint: true, handleExceptions: env.isProduction()&#125;))// [before]const logger = new winston.Logger(&#123; level: 'debug', transports: transports, exitOnError: false&#125;)// [after]module.exports = logger As you can see we’re using config.logging.console.level variable to define level of console logging. Let’s extend our config.template.js for logging:12345logging: &#123; console: &#123; level: 'debug' &#125;&#125; We could redefine this level for some environments. For production we could use this:12345logging: &#123; console: &#123; level: 'error' &#125;&#125; Further loggers require some additional packages to install, some config and init function which should be placed [before] or [after] logger init. File [before]packages:1yarn add mkdirp winston-daily-rotate-file config:1234567file: &#123; enabled: true, path: path.normalize(path.join(__dirname, '..', '..', 'logs')), level: 'info', json: false, exceptionFile: true&#125; NB: you should add const path = require(&#39;path&#39;) at the begin of your config files if you use path.init:123456789101112131415161718192021222324252627282930313233const path = require('path')const fs = require('fs')const mkdirp = require('mkdirp')/** * File transporter */if (config.logging.file.enabled) &#123; // Create logs directory const logDir = config.logging.file.path if (!fs.existsSync(logDir)) &#123; mkdirp(logDir) &#125; transports.push(new (require('winston-daily-rotate-file'))(&#123; filename: path.join(logDir, 'server.log'), level: config.logging.file.level || 'info', timestamp: true, json: config.logging.file.json || false, handleExceptions: true &#125;)) if (config.logging.file.exceptionFile) &#123; transports.push(new winston.transports.File(&#123; filename: path.join(logDir, 'exceptions.log'), level: 'error', timestamp: true, json: config.logging.file.json || false, prettyPrint: true, handleExceptions: true, humanReadableUnhandledException: true &#125;)) &#125;&#125; Logentries [before]packages:1yarn add le_node config:1234logentries: &#123; enabled: false, token: null&#125; init:123456789101112/** * Logentries transporter * https://logentries.com/ */if (config.logging.logentries.enabled &amp;&amp; config.logging.logentries.token) &#123; console.log('Logentries log transport enabled!') require('le_node') transports.push(new winston.transports.Logentries(&#123; level: 'debug', token: config.logging.logentries.token &#125;))&#125; Papertrail [before]packages:1yarn add winston-papertrail config:1234567papertrail: &#123; enabled: false, host: null, port: null, level: 'debug', program: 'vem'&#125; init:12345678910/** * Papertrail transporter * https://papertrailapp.com/ */if (config.logging.papertrail.enabled) &#123; console.log('Papertrail log transport enabled!') // eslint-disable-next-line no-unused-expressions require('winston-papertrail').Papertrail transports.push(new winston.transports.Papertrail(config.logging.papertrail))&#125; Loggly [after]packages:1yarn add winston-loggly-bulk config:1234567loggly: &#123; enabled: false, token: null, subdomain: null, tags: [], json: true&#125; init:1234567891011121314/** * Loggly transporter * https://www.loggly.com/ */if (config.logging.loggly.enabled &amp;&amp; config.logging.loggly.token) &#123; console.log('Loggly log transport enabled!') require('winston-loggly-bulk') logger.add(winston.transports.Loggly, &#123; inputToken: config.logging.loggly.token, subdomain: config.logging.loggly.subdomain, tags: config.logging.loggly.tags, json: config.logging.loggly.json &#125;)&#125; Logsene [after]packages:1yarn add winston-logsene config:1234logsene: &#123; enabled: false, token: null&#125; init:123456789101112/** * Logsene transporter * https://sematext.com/logsene/ */if (config.logging.logsene.enabled &amp;&amp; config.logging.logsene.token) &#123; console.log('Logsene log transport enabled!') const logsene = require('winston-logsene') logger.add(logsene, &#123; type: 'vem-server', token: config.logging.logsene.token &#125;)&#125; Logz.io [after]packages:1yarn add winston-logzio config:1234logzio: &#123; enabled: false, token: null&#125; init:1234567891011/** * Logz.io transporter * https://logz.io/ */if (config.logging.logzio.enabled &amp;&amp; config.logging.logzio.token) &#123; console.log('Logz.io log transport enabled!') const logzio = require('winston-logzio') logger.add(logzio, &#123; token: config.logging.logzio.token &#125;)&#125; Graylog [after]packages:1yarn add winston-graylog2 config:12345graylog: &#123; enabled: false, servers: [&#123;host: '192.168.1.100', port: 12201&#125;], facility: 'MEVN'&#125; init:12345678910111213141516/** * Graylog transporter * https://www.graylog.org/ */if (config.logging.graylog.enabled) &#123; console.log('Graylog log transport enabled! Servers: ' + JSON.stringify(config.logging.graylog.servers)) let graylog = require('winston-graylog2') logger.add(graylog, &#123; name: 'Graylog', level: 'debug', graylog: &#123; servers: config.logging.graylog.servers, facility: config.logging.graylog.facility &#125; &#125;)&#125; Entry pointOur server/index.js intended for complete server init and have a lot of stuff to init to. Now there’s just express, sessions and nuxt init, but this file will grow. Best practice is split this file.We already have an engine directory, so let’s move our express initialization into express.js file located in the engine directory:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const config = require('@config')const &#123;env&#125; = require('@helpers')const nuxtConfig = require('@/nuxt.config')const express = require('express')const session = require('express-session')const cookieParser = require('cookie-parser')const bodyParser = require('body-parser')const &#123;Nuxt, Builder&#125; = require('nuxt')/** * Initialize middlewares * @param &#123;any&#125; app */function initMiddleware (app) &#123; app.use(bodyParser.urlencoded(&#123; extended: true &#125;)) app.use(bodyParser.json()) app.use(cookieParser()) app.set('etag', true)&#125;/** * Initialize session * @param &#123;any&#125; app */function initSession (app) &#123; app.use(session(config.session))&#125;/** * Initialize Nuxt * @param &#123;any&#125; app */function initNuxt (app) &#123; nuxtConfig.dev = !env.isProduction() const nuxt = new Nuxt(nuxtConfig) if (nuxtConfig.dev) &#123; new Builder(nuxt).build() &#125; app.use(nuxt.render)&#125;module.exports = () =&gt; &#123; const app = express() initMiddleware(app) initSession(app) initNuxt(app) return app&#125; server/index.js:12345678require('module-alias/register')const app = require('@engine/express')()app.listen(3000, () =&gt; &#123; console.log(`Application was started at the 3000th port`)&#125;)exports = module.exports = app It looks much better now, isn’t it?We also split our middlewares just for make sure we’re using it in right order. Express extrasFirst of all, lets define ip and port in our configs:12ip: process.env.NODE_IP || '0.0.0.0',port: process.env.NODE_PORT || 3000 Now we could add little bit more logging information on server start:1234567891011121314151617181920require('module-alias/register')const config = require('@config')const logger = require('@engine/logger')const chalk = require('chalk')const moment = require('moment')const app = require('@engine/express')()logger.info(chalk.bold('-----------------[ Server starting at %s ]-----------------'), moment().format('YYYY-MM-DD HH:mm:ss.SSS'))app.listen(config.port, config.ip, () =&gt; &#123; logger.info('----------------------------[ Application started! ]----------------------------') logger.info(`Environment:\\t$&#123;chalk.underline.bold(process.env.NODE_ENV)&#125;`) logger.info(`IP:\\t\\t\\t$&#123;config.ip&#125;`) logger.info(`Port:\\t\\t\\t$&#123;config.port&#125;`) logger.info('--------------------------------------------------------------------------------')&#125;)exports = module.exports = app CompressionThis package will compress server response.1yarn add compression Include this into middlewares list of express.js:123456789101112const compress = require('compression')...function initMiddleware (app) &#123; app.use(compress(&#123; filter: (req, res) =&gt; &#123; return /json|text|javascript|css/.test(res.getHeader('Content-Type')) &#125;, level: 3, threshold: 512 &#125;)) ...&#125; MorganIt’s usefull to know what requests your server got. That’s why I recommend to include morgan:1yarn add morgan express.js:1234567891011121314151617const logger = require('@engine/logger')const morgan = require('morgan')...function initMiddleware (app) &#123; ... if (env.isDev()) &#123; const Stream = require('stream').Stream const mlStream = new Stream() mlStream.writable = true mlStream.write = data =&gt; &#123; return logger.debug(data) &#125; app.use(morgan('dev', &#123; stream: mlStream &#125;)) &#125;&#125; This config using our winston logger for morgan. HelmetThis little middleware adds some protection for requests to prevent some attacks.1yarn add helmet 123456789101112131415161718192021222324const helmet = require('helmet').../** * Initiliaze Helmet security module * @param &#123;any&#125; app */function initHelmetHeaders (app) &#123; app.use(helmet.xssFilter()) app.use(helmet.noSniff()) app.use(helmet.frameguard()) app.use(helmet.ieNoOpen()) app.use(helmet.hidePoweredBy())&#125;...module.exports = () =&gt; &#123; const app = express() initMiddleware(app) initHelmetHeaders(app) initSession(app) initNuxt(app) return app&#125; Extra helpersSafe stopFor further work we have to be sure server stopped correctly, all connections closed, etc. So let’s make new helper safeStop.js:123456789101112131415const logger = require('@engine/logger')const chalk = require('chalk')const moment = require('moment')const smoothExit = async () =&gt; &#123; const exit = () =&gt; &#123; logger.info() logger.info(chalk.bold('------[ Server stopped at %s Uptime: %s ]------'), moment().format('YYYY-MM-DD HH:mm:ss.SSS'), moment.duration(process.uptime() * 1000).humanize()) return process.exit(0) &#125; return exit()&#125;process.on('SIGINT', smoothExit).on('SIGTERM', smoothExit) And call this in the server/index.js before app.listen:123require('@helpers/safeStop')...app.listen(...) System infoLet’s print information about system where server started. Make sysinfo.js helper.It require some additional packages:1yarn add clui pretty-bytes server/helpers/sysinfo.js:1234567891011121314const logger = require('@engine/logger')const os = require('os')const gauge = require('clui').Gaugeconst pretty = require('pretty-bytes')const total = os.totalmem()const free = os.freemem()const used = total - freeconst human = pretty(free)logger.info(`CPU:\\t\\t\\tArch: $&#123;os.arch()&#125;, Cores: $&#123;os.cpus().length&#125;`)logger.info(`Memory:\\t\\t$&#123;gauge(used, total, 20, total * 0.8, human + ' free')&#125;`)logger.info(`OS:\\t\\t\\t$&#123;os.platform()&#125; ($&#123;os.type()&#125;)`) And call him after server start inside app.listen:12345app.listen(..., () =&gt; &#123; ... require('@helpers/sysinfo') logger.info('--------------------------------------------------------------------------------')&#125;) This part wraps up 03-logging-split-extras git branch."},{"title":"Full Stack (Node + Express + MongoDb + Vue + Nuxt) application. Part 2: Helpers, Configs and Session","permalink":"http://iworb.github.io/2018/02/13/02-nemvn/","text":"HelpersHelpers will land in server/helpers directory, so add an alias in package.json for it:1&quot;@helpers&quot;: &quot;./server/helpers&quot; EnvironmentLet’s add env.js helper which checks our environment:12345678910111213module.exports = &#123; isDev () &#123; return !process.env.NODE_ENV || process.env.NODE_ENV === 'development' &#125;, isProduction () &#123; return process.env.NODE_ENV === 'production' &#125;, isTest () &#123; return process.env.NODE_ENV === 'test' &#125;&#125; To export this module in easy way lets make an index for helpers:12345const env = require('./env')module.exports = &#123; env&#125; Token generatorAnother one nifty helper intended for token generation for secrets.1yarn add uuid-token-generator tokgen.js:123456let TokenGenerator = require('uuid-token-generator')let tokgen = new TokenGenerator(256, TokenGenerator.BASE62)module.exports = function () &#123; return tokgen.generate()&#125; And extend index file for this new helper:1234567const env = require('./env')const tokgen = require('./tokgen')module.exports = &#123; env, tokgen&#125; ConfigsConfig should be flexible, so we have to merge it into separate files: base.js - basic configuration which should be a skeleton of config; config.template.js - template for config.js file, which could be used to set your own secrets. It is excluded from git, so we need a template to create new one if there’s new instance; dev.js, prod.js and test.js - confings based on environment; index.js - summary config.Let’s init them with following code:1module.exports = &#123;&#125; As an example let’s make a session config.base.js:123456789101112131415module.exports = &#123; session: &#123; resave: true, saveUninitialized: false, cookie: &#123; // reset session after 1 week maxAge: 7 * 24 * (60 * 60 * 1000), // we will use cookies just for HTTP, not js // JS will send this cookies only from current domain httpOnly: true, // should be 'true' if you're using https secure: false &#125; &#125;&#125; Now we have almost complete session config but secret. Each user have to define his own session, so lets make our template which will generate secret for a session if there’s no config.js file.config.template.js:12345678910111213141516module.exports = &#123; session: &#123; secret: '&#123;&#123;sessionSecret&#125;&#125;', resave: true, saveUninitialized: false, cookie: &#123; // reset session after 1 week maxAge: 7 * 24 * (60 * 60 * 1000), // we will use cookies just for HTTP, not js // JS will send this cookies only from current domain httpOnly: true, // should be 'true' if you're using https secure: false &#125; &#125;&#125; and another stuff in double braces will be replaced with provided data.To improve console logging and js functionality I gonna include this modules into project:1yarn add chalk lodash There’s how index.js file looks:123456789101112131415161718192021222324252627282930313233343536373839404142434445const path = require('path')const fs = require('fs')const _ = require('lodash')const chalk = require('chalk')const &#123;tokgen, env&#125; = require('@helpers')let config = &#123;&#125;try &#123; // [1] if (!fs.existsSync(path.join(__dirname, 'config.js'))) &#123; console.warn(chalk.yellow.bold('`config.js` for server settings was not found! Generating new `config.js` file')) const template = fs.readFileSync(path.join(__dirname, 'config.template.js')) _.templateSettings.interpolate = /&#123;&#123;([\\s\\S]+?)&#125;&#125;/g const compiled = _.template(template) const replacements = &#123; sessionSecret: tokgen() &#125; fs.writeFileSync(path.join(__dirname, 'config.js'), compiled(replacements)) console.warn(chalk.green.bold('New `config.js` for server settings file was generated. You could update your settings here: \"server/config/config.js\"')) &#125; config = require('./config')&#125; catch (error) &#123; console.warn(chalk.red.bold('\\r\\n==============================================')) console.warn(chalk.red.bold(' Unable to load external `config.js` file!')) console.warn(chalk.red.bold(' ', error)) console.warn(chalk.red.bold('==============================================\\r\\n')) process.exit(1)&#125;// [2]let envConfig = &#123;&#125;if (env.isDev()) &#123; envConfig = require('./dev')&#125; else if (env.isTest()) &#123; envConfig = require('./test')&#125; else if (env.isProduction()) &#123; envConfig = require('./prod')&#125;// [3]const base = require('./base')module.exports = _.defaultsDeep(envConfig, config, base) First of all we have to check is there config.js [1] file exists. If no we’re reading our config.template.js and replace template variables with generated values and make config.js.Next [2] we’re reading environment-based config and [3] base one, than return merged config.Last thing is module alias for config folder:1&quot;@config&quot;: &quot;./server/config&quot; Session1yarn add express-session cookie-parser body-parser Add using of session in our application lets extend server/index.js file:123456789101112131415161718require('module-alias/register')const config = require('@config')const express = require('express')const session = require('express-session')const bodyParser = require('body-parser')const cookieParser = require('cookie-parser')const app = express()const configSession = config.sessionapp.use(bodyParser.urlencoded(&#123; extended: true&#125;))app.use(bodyParser.json())app.use(cookieParser())app.use(session(configSession))const &#123;Nuxt, Builder&#125; = require('nuxt')... This part wraps up 02-helpers-config-session git branch."},{"title":"Full Stack (Node + Express + MongoDb + Vue + Nuxt) application. Part 2: Nuxt and Expres","permalink":"http://iworb.github.io/2018/02/12/01-nemvn/","text":"Nuxt12yarn add nuxtyarn add stylus stylus-loader --dev Lets make client directory in our project. It will contain whole frontend code made with Nuxt.Also, create nuxt.config.js in the root folder to define Nuxt settings.Lets define client directory and loader color:1234module.exports = &#123; loading: &#123;color: '#3B8070'&#125;, srcDir: 'client/'&#125; Lets make a single page. Create client/pages directory and index.vue file within. Then fill this file with some test data:123456789101112131415161718192021&lt;template&gt; &lt;div&gt; Hello #&#123;&#123; counter &#125;&#125; &lt;button @click=&quot;counter = counter +1&quot;&gt;+1&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; counter: 0 &#125; &#125; &#125;&lt;/script&gt;&lt;style lang=&quot;stylus&quot;&gt; div background-color lightblue&lt;/style&gt; ExpressLets make an entry point: in the server directory create index.js.Before further work we have to install some modules:1yarn add express server/index.js:1234567891011121314151617181920require('module-alias/register') // Details at Part 0/Module alias const express = require('express')const app = express()const &#123;Nuxt, Builder&#125; = require('nuxt')const nuxtConfig = require('@/nuxt.config')nuxtConfig.dev = process.env.NODE_ENV !== 'production'const nuxt = new Nuxt(nuxtConfig)if (nuxtConfig.dev) &#123; new Builder(nuxt).build()&#125;app.use(nuxt.render)app.listen(3000, () =&gt; &#123; console.log(`Application was started at the 3000th port`)&#125;)exports = module.exports = app Now we should modify our package.json and set our main script to server/index.js.That’s all. Now we can run our server with yarn run and we’ll got simple page located on http://localhost:3000.This part wraps up 01-nuxt-express git branch."},{"title":"Full Stack (Node + Express + MongoDb + Vue + Nuxt) application. Part 0: Usefull stuff","permalink":"http://iworb.github.io/2018/02/12/00-nemvn/","text":"BeginTo start new project create new directory and run this commends to init node application and git:12yarn initgit init I will use yarn, but you could use npm, commands are mostly the same.To configure git lets add .gitignore file:12345678910111213141516171819202122232425262728293031################################################# Dependencies################################################node_modules################################################# Node.js / NPM################################################lib-cov*.seed*.log*.out*.pidnpm-debug.log################################################# Miscellaneous################################################*~*#.DS_STORE.netbeansnbproject.idea.node_historydump.rdb.nuxt.vscode LinterLet’s add some style check:123yarn add eslint.\\node_modules\\.bin\\eslint --inityarn install We will use Standard style guide in JSON format.Let’s expand it little bit:123456789101112131415&#123; \"env\": &#123; \"es6\": true, \"node\": true, \"mocha\": true &#125;, \"parserOptions\": &#123; \"ecmaVersion\": 8 &#125;, \"extends\": \"standard\", \"rules\": &#123; \"arrow-parens\": [\"error\", \"as-needed\"], \"linebreak-style\": [\"error\", \"unix\"] &#125;&#125; It will extend our environment, set ECMA Script version to 8th and define some rules. Module aliasWorking with relative path is kidna hard, so lets make it easier:1yarn add module-alias Now we can define aliases which will makes relative paths looks like absolute one.In the package.json we could add new section _moduleAliases and define some paths:123&quot;_moduleAliases&quot;: &#123; &quot;@&quot;: &quot;.&quot;&#125; @ - root path Cross env variablesTo define node environment variables in package.json you could send it before running node by itself, but in the windows it won’t work, so let’s fix that:1yarn add cross-env Now we can add some scripts:12&quot;start&quot;: &quot;nuxt build &amp; cross-env NODE_ENV=production node server/index.js&quot;,&quot;dev&quot;: &quot;node server/index.js&quot; Handling date and timeLet’s use moment package for date and time:1yarn add moment"}]}